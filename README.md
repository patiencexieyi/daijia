1、Drools规则引擎：为了解决项目业务中因规则可能随时进行调整，而改变编码的问题，引入了规则引擎Drools，将应用程序中的业务决策部分分离出来，使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效。把业务流程从代码中剥离出来。

drools规则引擎由以下三部分构成：

- Working Memory（工作内存）
- Rule Base（规则库）
- Inference Engine（推理引擎）

其中Inference Engine（推理引擎）又包括：

- Pattern Matcher（匹配器）     具体匹配哪一个规则，由这个完成
- Agenda(议程)
- Execution Engine（执行引擎）

定义了根据行驶里程和接单时间段制定收费规则
定义了系统奖励

2、Xxl-JOB分布式任务调度框架：使用Xxl-JOB分布式任务调度框架，解决了用户重复下单的问题，利用任务调度查询订单状态，来判断是否继续执行。

3、分布式锁解决司机抢单：添加Redisson分布式锁到司机抢单
* Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。
* Redisson的宗旨是：促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。
本地锁的局限性：synchronized 及lock锁，都是本地锁，只在当前jvm生效

4、MongoDB：数据库-集合-文档（记录），文档类似于JSON对象，结构称为BSON
为了解决数据大量增长的时候系统的可扩展性和敏捷性，在项目中将司机的实时位置信息存入MongoDB，也有利于乘客端获取司机的最新动向
存储录音文件中的文本内容

5、Minio：
基于Minio进行文件的存取服务，存储录音文件


6、异步编排：问题：司机结束代驾，有很多远程调用，一个一个执行，效率低下
可以多线程方式完成这些操作，使用CompletableFuture实现异步编排进行优化
使用`CompletableFuture`可用于线程异步编排，使原本串行执行的代码，变为并行执行，提高代码执行速度。
#去了解线程池的原理

运用内网穿透工具，配置：腾讯调用我们这边的接口路径
支付回调，微信成功支付后，腾讯服务回调我们的接口，进行之后的更新订单和相关的状态
目的就是为了，让用户支付后能快速返回支付成功的消息，相关的更新操作留到后面用消息队列执行完成。

7、RabbitMQ：
异步，保证数据最终一致性
使用RabbitMQ里面TTL和死信队列实现超时订单自动取消
* 使用延迟队列消息实现订单到时间自动取消功能**

第一种 使用RabbitMQ里面TTL和死信队列实现

第二种 在RabbitMQ安装延迟队列实现

第三种 使用Redisson实现

8、分布式事务：Seata框架 @GlobalTransactional


9、乐观锁+分布式锁（悲观锁）解决优惠券超额领取
乐观锁：常用于更新业务处理
分布式锁（悲观锁）：常用于新增业务处理

10、自定义注解+AOP




